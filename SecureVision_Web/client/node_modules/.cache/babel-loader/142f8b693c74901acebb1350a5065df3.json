{"ast":null,"code":"var _jsxFileName = \"/Users/aleclawlor/SecureVision/client/src/components/cameraFeed/detection.js\";\nimport React from 'react';\n\nconst cocoSsd = require('@tensorflow-models/coco-ssd');\n\nclass App extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.videoRef = React.createRef();\n    this.canvasRef = React.createRef();\n    this.video = document.createElement('video');\n    this.styles = {\n      position: 'fixed',\n      top: 150,\n      left: 150\n    };\n\n    this.imageContrast = (imageData, amount) => {\n      let d = imageData.data;\n      let contrast = amount / 100 + 1;\n      let intercept = 128 * (1 - contrast);\n\n      for (let i = 0; i < d.length; i += 4) {\n        d[i] = d[i] * contrast + intercept;\n        d[i + 1] = d[i + 1] * contrast + intercept;\n        d[i + 2] = d[i + 2] * contrast + intercept;\n      }\n\n      return imageData;\n    };\n\n    this.imageGrayScale = (imageData, width, height) => {\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          let i = y * 4 * width + x * 4;\n          let avg = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;\n          imageData.data[i] = avg;\n          imageData.data[i + 1] = avg;\n          imageData.data[i + 2] = avg;\n        }\n      }\n\n      return imageData;\n    };\n\n    this.imageThreshold = (imageData, threshold) => {\n      for (let i = 0; i < imageData.data.length; i += 4) {\n        imageData.data[i] = imageData.data[i + 1] = imageData.data[i + 2] = imageData.data[i + 1] > threshold ? 255 : 0;\n      }\n\n      return imageData;\n    };\n\n    this.detectFromVideoFrame = (model, video) => {\n      model.detect(video).then(predictions => {\n        this.showDetections(predictions, video);\n        requestAnimationFrame(() => {\n          this.detectFromVideoFrame(model, video);\n        });\n      }, error => {\n        console.error(error);\n      });\n    };\n\n    this.stall = () => {\n      setInterval(() => {\n        let x = 'anc';\n      }, 1000);\n    };\n\n    this.finished = false;\n\n    this.showDetections = (predictions, video) => {\n      const ctx = this.canvasRef.current.getContext(\"2d\");\n      let vid = this.videoRef.current;\n\n      vid.onended = () => {\n        this.finished = true;\n        alert(\"video has ended\");\n      };\n\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      const font = \"24px helvetica\";\n      ctx.font = font;\n      ctx.textBaseline = \"top\";\n      predictions.forEach(prediction => {\n        if (this.finished) {\n          return;\n        }\n\n        console.log(prediction);\n\n        if (prediction.class === 'car' || prediction.class === 'motorcycle' || prediction.class === 'truck' || prediction.class === 'bus') {\n          const x = prediction.bbox[0];\n          const y = prediction.bbox[1];\n          const width = prediction.bbox[2];\n          const height = prediction.bbox[3]; // Draw the bounding box.\n\n          ctx.strokeStyle = \"#FF7801\";\n          ctx.lineWidth = 1;\n          ctx.strokeRect(x, y, width, height); // Draw the label background.\n\n          ctx.fillStyle = \"#FF7801\";\n          const textWidth = ctx.measureText(prediction.class).width;\n          const textHeight = parseInt(font, 10); // draw top left rectangle\n\n          ctx.fillRect(x, y, textWidth + 10, textHeight + 10); // draw bottom left rectangle\n\n          ctx.fillRect(x, y + height - textHeight, textWidth + 15, textHeight + 10);\n          ctx.fillStyle = \"#000000\";\n          ctx.fillText(prediction.class, x, y);\n          ctx.fillText(prediction.score.toFixed(2), x, y + height - textHeight); // let tempCanvas = document.createElement('canvas')\n          // let tempContext = tempCanvas.getContext('2d')\n          // tempContext.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height)\n          // let imageData = tempContext.getImageData(x, y, width, height)\n          // // let contrastData = this.imageContrast(imageData, 120)\n          // // let grayScaleData = this.imageGrayScale(contrastData, tempCanvas.width, tempCanvas.height)\n          // // let thresholdData = this.imageThreshold(grayScaleData, 170)  \n          // tempContext.putImageData(imageData, 0, 0)\n          // let currentCar = new Image()\n          // currentCar.src = tempCanvas.toDataURL('image/png')\n          // document.body.append(currentCar)\n          // // this.characterRecognize(currentCar)\n        }\n      });\n    };\n  }\n\n  componentDidMount() {\n    if (navigator.mediaDevices.getUserMedia || navigator.mediaDevices.webkitGetUserMedia) {\n      // can later be used to get the live stream from a school's security camera\n      // const webcamPromise = navigator.mediaDevices\n      //   .getUserMedia({\n      //     video: true,\n      //     audio: false,\n      //   })\n      //   .then(stream => {\n      //     // pass the current frame to the window.stream\n      //     // window.stream = 'stream';\n      //     // // pass the stream to the videoRef\n      //     // this.videoRef.current.srcObject = 'stream';\n      //     return new Promise(resolve => {\n      //       this.videoRef.current.onloadedmetadata = () => {\n      //         resolve();\n      //       };\n      //     });\n      //   }, (error) => {\n      //     console.error(error)\n      //   });\n      // define a Promise that will be used to load the model\n      const loadlModelPromise = cocoSsd.load(); // resolve all the Promises\n\n      Promise.all([loadlModelPromise]).then(values => {\n        this.detectFromVideoFrame(values[0], this.videoRef.current);\n      }).catch(error => {\n        console.error(error);\n      });\n    }\n  }\n\n  render() {\n    console.log(this.videoRef);\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 183\n      },\n      __self: this\n    }, React.createElement(\"video\", {\n      id: \"video\",\n      style: this.styles,\n      autoPlay: true,\n      muted: true,\n      src: \"./plateTest.mp4\",\n      ref: this.videoRef,\n      width: \"720\",\n      height: \"600\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 184\n      },\n      __self: this\n    }), React.createElement(\"canvas\", {\n      style: this.styles,\n      ref: this.canvasRef,\n      width: \"720\",\n      height: \"650\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 194\n      },\n      __self: this\n    }));\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/aleclawlor/SecureVision/client/src/components/cameraFeed/detection.js"],"names":["React","cocoSsd","require","App","Component","videoRef","createRef","canvasRef","video","document","createElement","styles","position","top","left","imageContrast","imageData","amount","d","data","contrast","intercept","i","length","imageGrayScale","width","height","y","x","avg","imageThreshold","threshold","detectFromVideoFrame","model","detect","then","predictions","showDetections","requestAnimationFrame","error","console","stall","setInterval","finished","ctx","current","getContext","vid","onended","alert","clearRect","canvas","font","textBaseline","forEach","prediction","log","class","bbox","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","textHeight","parseInt","fillRect","fillText","score","toFixed","componentDidMount","navigator","mediaDevices","getUserMedia","webkitGetUserMedia","loadlModelPromise","load","Promise","all","values","catch","render"],"mappings":"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","sourcesContent":["import React from 'react'\nconst cocoSsd = require('@tensorflow-models/coco-ssd')\n\nclass App extends React.Component {\n\n    // reference to video and canvas\n    videoRef = React.createRef();\n    canvasRef = React.createRef();\n    video = document.createElement('video')\n  \n    styles = {\n      position: 'fixed',\n      top: 150,\n      left: 150,\n    };\n  \n    // characterRecognize = (image) => {\n    //   Tesseract.recognize(\n    //     image,\n    //     'eng',\n    //     // { logger: m => console.log(m) }\n    //   ).then(({ data: { text }}) => {\n    //     console.log(text)\n    //   })\n    // }\n  \n    imageContrast = (imageData, amount) => {\n  \n      let d = imageData.data\n  \n      let contrast = (amount/100) + 1\n      let intercept = 128 * (1-contrast)\n  \n      for(let i = 0; i < d.length; i+=4){\n          d[i] = d[i]*contrast + intercept;\n          d[i+1] = d[i+1]*contrast + intercept;\n          d[i+2] = d[i+2]*contrast + intercept;\n      }\n      return imageData\n    }\n  \n    imageGrayScale = (imageData, width, height) => {\n      for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n          let i = (y*4) * width + x * 4\n          let avg = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3\n          imageData.data[i] = avg \n          imageData.data[i + 1] = avg \n          imageData.data[i + 2] = avg \n        }\n      }\n      return imageData\n    }\n  \n    imageThreshold = (imageData, threshold) => {\n      for(let i = 0; i < imageData.data.length; i += 4){\n          imageData.data[i] = imageData.data[i+1] = imageData.data[i+2] = imageData.data[i+1] > threshold ? 255 : 0\n      }\n      return imageData\n    }\n  \n    detectFromVideoFrame = (model, video) => {\n      model.detect(video).then(predictions => {\n        this.showDetections(predictions, video);\n        requestAnimationFrame(() => {\n          this.detectFromVideoFrame(model, video);\n        });\n      }, (error) => {\n        console.error(error)\n      });\n    };\n  \n    stall = () => {\n      setInterval(() => {\n        let x = 'anc'},1000)\n    }\n  \n    finished = false \n  \n    showDetections = (predictions, video) => {\n      const ctx = this.canvasRef.current.getContext(\"2d\");\n      \n      let vid = this.videoRef.current\n      vid.onended = () => {\n        this.finished = true \n        alert(\"video has ended\")\n      }\n  \n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      const font = \"24px helvetica\";\n      ctx.font = font;\n      ctx.textBaseline = \"top\";\n      predictions.forEach(prediction => {\n  \n      if(this.finished){\n        return \n      }\n  \n        console.log(prediction)\n  \n        if(prediction.class === 'car' || prediction.class === 'motorcycle' || prediction.class === 'truck' || prediction.class === 'bus'){\n        const x = prediction.bbox[0];\n        const y = prediction.bbox[1];\n        const width = prediction.bbox[2];\n        const height = prediction.bbox[3];\n        // Draw the bounding box.\n        ctx.strokeStyle = \"#FF7801\";\n        ctx.lineWidth = 1;\n        ctx.strokeRect(x, y, width, height);\n        // Draw the label background.\n        ctx.fillStyle = \"#FF7801\";\n        const textWidth = ctx.measureText(prediction.class).width;\n        const textHeight = parseInt(font, 10);\n        // draw top left rectangle\n        ctx.fillRect(x, y, textWidth + 10, textHeight + 10);\n        // draw bottom left rectangle\n        ctx.fillRect(x, y + height - textHeight, textWidth + 15, textHeight + 10);\n  \n        ctx.fillStyle = \"#000000\";\n        ctx.fillText(prediction.class, x, y);\n        ctx.fillText(prediction.score.toFixed(2), x, y + height - textHeight);\n  \n        // let tempCanvas = document.createElement('canvas')\n        // let tempContext = tempCanvas.getContext('2d')\n        // tempContext.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height)\n        // let imageData = tempContext.getImageData(x, y, width, height)\n        \n        // // let contrastData = this.imageContrast(imageData, 120)\n        // // let grayScaleData = this.imageGrayScale(contrastData, tempCanvas.width, tempCanvas.height)\n        // // let thresholdData = this.imageThreshold(grayScaleData, 170)  \n        // tempContext.putImageData(imageData, 0, 0)\n  \n        // let currentCar = new Image()\n        // currentCar.src = tempCanvas.toDataURL('image/png')\n        // document.body.append(currentCar)\n        // // this.characterRecognize(currentCar)\n        }\n      });\n    };\n  \n    componentDidMount() {\n  \n      if (navigator.mediaDevices.getUserMedia || navigator.mediaDevices.webkitGetUserMedia) {\n        \n        // can later be used to get the live stream from a school's security camera\n        // const webcamPromise = navigator.mediaDevices\n        //   .getUserMedia({\n        //     video: true,\n        //     audio: false,\n        //   })\n        //   .then(stream => {\n        //     // pass the current frame to the window.stream\n        //     // window.stream = 'stream';\n        //     // // pass the stream to the videoRef\n        //     // this.videoRef.current.srcObject = 'stream';\n  \n        //     return new Promise(resolve => {\n        //       this.videoRef.current.onloadedmetadata = () => {\n        //         resolve();\n        //       };\n        //     });\n        //   }, (error) => {\n        //     console.error(error)\n        //   });\n  \n        // define a Promise that will be used to load the model\n        const loadlModelPromise = cocoSsd.load();\n  \n        // resolve all the Promises\n        Promise.all([loadlModelPromise])\n          .then(values => {\n            this.detectFromVideoFrame(values[0], this.videoRef.current);\n          })\n          .catch(error => {\n            console.error(error);\n          });\n      }\n    }\n  \n    render() {\n      console.log(this.videoRef)\n      return (\n        <div> \n          <video\n            id=\"video\"\n            style={this.styles}\n            autoPlay\n            muted\n            src=\"./plateTest.mp4\"\n            ref={this.videoRef}\n            width=\"720\"\n            height=\"600\"\n          />\n          <canvas style={this.styles} ref={this.canvasRef} width=\"720\" height=\"650\" />\n        </div>\n      );\n    }\n  }\n  \nexport default App"]},"metadata":{},"sourceType":"module"}